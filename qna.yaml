version: 3
created_by: Prithiviraj_N
domain: Z/Os Patch Fixing
seed_examples:
  - context: |
         """
            #! /bin/sh
            # test-driver - basic testsuite driver script.

            scriptversion=2018-03-07.03; # UTC

            # Copyright (C) 2011-2021 Free Software Foundation, Inc.
            #
            # This program is free software; you can redistribute it and/or modify
            # it under the terms of the GNU General Public License as published by
            # the Free Software Foundation; either version 2, or (at your option)
            # any later version.
            #
            # This program is distributed in the hope that it will be useful,
            # but WITHOUT ANY WARRANTY; without even the implied warranty of
            # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
            # GNU General Public License for more details.
            #
            # You should have received a copy of the GNU General Public License
            # along with this program.  If not, see <https://www.gnu.org/licenses/>.

            # As a special exception to the GNU General Public License, if you
            # distribute this file as part of a program that contains a
            # configuration script generated by Autoconf, you may include it under
            # the same distribution terms that you use for the rest of that program.

            # This file is maintained in Automake, please report
            # bugs to <bug-automake@gnu.org> or send patches to
            # <automake-patches@gnu.org>.

            # Make unconditional expansion of undefined variables an error.  This
            # helps a lot in preventing typo-related bugs.
            set -u

            usage_error ()
            {
            echo "$0: $*" >&2
            print_usage >&2
            exit 2
            }

            print_usage ()
            {
            cat <<END
            Usage:
            test-driver --test-name NAME --log-file PATH --trs-file PATH
                        [--expect-failure {yes|no}] [--color-tests {yes|no}]
                        [--enable-hard-errors {yes|no}] [--]
                        TEST-SCRIPT [TEST-SCRIPT-ARGUMENTS]

            The '--test-name', '--log-file' and '--trs-file' options are mandatory.
            See the GNU Automake documentation for information.
            END
            }

            test_name= # Used for reporting.
            log_file=  # Where to save the output of the test script.
            trs_file=  # Where to save the metadata of the test run.
            expect_failure=no
            color_tests=no
            enable_hard_errors=yes
            while test $# -gt 0; do
            case $1 in
            --help) print_usage; exit $?;;
            --version) echo "test-driver $scriptversion"; exit $?;;
            --test-name) test_name=$2; shift;;
            --log-file) log_file=$2; shift;;
            --trs-file) trs_file=$2; shift;;
            --color-tests) color_tests=$2; shift;;
            --expect-failure) expect_failure=$2; shift;;
            --enable-hard-errors) enable_hard_errors=$2; shift;;
            --) shift; break;;
            -*) usage_error "invalid option: '$1'";;
            *) break;;
            esac
            shift
            done

            missing_opts=
            test x"$test_name" = x && missing_opts="$missing_opts --test-name"
            test x"$log_file"  = x && missing_opts="$missing_opts --log-file"
            test x"$trs_file"  = x && missing_opts="$missing_opts --trs-file"
            if test x"$missing_opts" != x; then
            usage_error "the following mandatory options are missing:$missing_opts"
            fi

            if test $# -eq 0; then
            usage_error "missing argument"
            fi

            if test $color_tests = yes; then
            # Keep this in sync with 'lib/am/check.am:$(am__tty_colors)'.
            red='' # Red.
            grn='' # Green.
            lgn='' # Light green.
            blu='' # Blue.
            mgn='' # Magenta.
            std=''     # No color.
            else
            red= grn= lgn= blu= mgn= std=
            fi

            do_exit='rm -f $log_file $trs_file; (exit $st); exit $st'
            trap "st=129; $do_exit" 1
            trap "st=130; $do_exit" 2
            trap "st=141; $do_exit" 13
            trap "st=143; $do_exit" 15

            # Test script is run here. We create the file first, then append to it,
            # to ameliorate tests themselves also writing to the log file. Our tests
            # don't, but others can (automake bug#35762).
            : >"$log_file"
            "$@" >>"$log_file" 2>&1
            estatus=$?

            if test $enable_hard_errors = no && test $estatus -eq 99; then
            tweaked_estatus=1
            else
            tweaked_estatus=$estatus
            fi

            case $tweaked_estatus:$expect_failure in
            0:yes) col=$red res=XPASS recheck=yes gcopy=yes;;
            0:*)   col=$grn res=PASS  recheck=no  gcopy=no;;
            77:*)  col=$blu res=SKIP  recheck=no  gcopy=yes;;
            99:*)  col=$mgn res=ERROR recheck=yes gcopy=yes;;
            *:yes) col=$lgn res=XFAIL recheck=no  gcopy=yes;;
            *:*)   col=$red res=FAIL  recheck=yes gcopy=yes;;
            esac

            # Report the test outcome and exit status in the logs, so that one can
            # know whether the test passed or failed simply by looking at the '.log'
            # file, without the need of also peaking into the corresponding '.trs'
            # file (automake bug#11814).
            echo "$res $test_name (exit status: $estatus)" >>"$log_file"

            # Report outcome to console.
            echo "${col}${res}${std}: $test_name"

            # Register the test result, and other relevant metadata.
            echo ":test-result: $res" > $trs_file
            echo ":global-test-result: $res" >> $trs_file
            echo ":recheck: $recheck" >> $trs_file
            echo ":copy-in-global-log: $gcopy" >> $trs_file

            # Local Variables:
            # mode: shell-script
            # sh-indentation: 2
            # eval: (add-hook 'before-save-hook 'time-stamp)
            # time-stamp-start: "scriptversion="
            # time-stamp-format: "%:y-%02m-%02d.%02H"
            # time-stamp-time-zone: "UTC0"
            # time-stamp-end: "; # UTC"
            # End:
         """,
         """
            /* Program name management.
            Copyright (C) 2016-2024 Free Software Foundation, Inc.

            This program is free software: you can redistribute it and/or modify
            it under the terms of the GNU Lesser General Public License as published by
            the Free Software Foundation; either version 2.1 of the License, or
            (at your option) any later version.

            This program is distributed in the hope that it will be useful,
            but WITHOUT ANY WARRANTY; without even the implied warranty of
            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
            GNU Lesser General Public License for more details.

            You should have received a copy of the GNU Lesser General Public License
            along with this program.  If not, see <https://www.gnu.org/licenses/>.  */

            #include <config.h>

            /* Specification.  Also get __argv declaration.  */
            #include <stdlib.h>

            #include <errno.h> /* get program_invocation_name declaration */

            #ifdef _AIX
            # include <unistd.h>
            # include <procinfo.h>
            # include <string.h>
            #endif

            #ifdef __MVS__
            # ifndef _OPEN_SYS
            #  define _OPEN_SYS
            # endif
            # include <string.h>
            # include <sys/ps.h>
            #endif

            #ifdef __hpux
            # include <unistd.h>
            # include <sys/param.h>
            # include <sys/pstat.h>
            # include <string.h>
            #endif

            #if defined __sgi || defined __osf__
            # include <string.h>
            # include <unistd.h>
            # include <stdio.h>
            # include <fcntl.h>
            # include <sys/procfs.h>
            #endif

            #if defined __SCO_VERSION__ || defined __sysv5__
            # include <fcntl.h>
            # include <string.h>
            #endif

            #include "basename-lgpl.h"

            #ifndef HAVE_GETPROGNAME  /* not Mac OS X, FreeBSD, NetBSD, OpenBSD >= 5.4, Solaris >= 11, Cygwin, Android API level >= 21 */
            char const *
            getprogname (void)
            {
            # if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME                /* glibc, BeOS */
            /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */
            return program_invocation_short_name;
            # elif HAVE_DECL_PROGRAM_INVOCATION_NAME                    /* glibc, BeOS */
            /* https://www.gnu.org/software/libc/manual/html_node/Error-Messages.html */
            return last_component (program_invocation_name);
            # elif HAVE_GETEXECNAME                                     /* Solaris */
            /* https://docs.oracle.com/cd/E19253-01/816-5168/6mbb3hrb1/index.html */
            const char *p = getexecname ();
            if (!p)
                p = "?";
            return last_component (p);
            # elif HAVE_DECL___ARGV                                     /* mingw, MSVC */
            /* https://docs.microsoft.com/en-us/cpp/c-runtime-library/argc-argv-wargv */
            const char *p = __argv && __argv[0] ? __argv[0] : "?";
            return last_component (p);
            # elif HAVE_VAR___PROGNAME                                  /* OpenBSD, Android, QNX */
            /* https://man.openbsd.org/style.9 */
            /* http://www.qnx.de/developers/docs/6.5.0/index.jsp?topic=%2Fcom.qnx.doc.neutrino_lib_ref%2Fp%2F__progname.html */
            /* Be careful to declare this only when we absolutely need it
                (OpenBSD 5.1), rather than when it's available.  Otherwise,
                its mere declaration makes program_invocation_short_name
                malfunction (have zero length) with Fedora 25's glibc.  */
            extern char *__progname;
            const char *p = __progname;
            #  if defined __ANDROID__
            return last_component (p);
            #  else
            return p && p[0] ? p : "?";
            #  endif
            # elif _AIX                                                 /* AIX */
            /* Idea by Bastien ROUCARIÃˆS,
                https://lists.gnu.org/r/bug-gnulib/2010-12/msg00095.html
                Reference: https://www.ibm.com/support/knowledgecenter/en/ssw_aix_61/com.ibm.aix.basetrf1/getprocs.htm
            */
            static char *p;
            static int first = 1;
            if (first)
                {
                first = 0;
                pid_t pid = getpid ();
                struct procentry64 procs;
                p = (0 < getprocs64 (&procs, sizeof procs, NULL, 0, &pid, 1)
                    ? strdup (procs.pi_comm)
                    : NULL);
                if (!p)
                    p = "?";
                }
            return p;
            # elif defined __hpux
            static char *p;
            static int first = 1;
            if (first)
                {
                first = 0;
                pid_t pid = getpid ();
                struct pst_status status;
                if (pstat_getproc (&status, sizeof status, 0, pid) > 0)
                    {
                    char *ucomm = status.pst_ucomm;
                    char *cmd = status.pst_cmd;
                    if (strlen (ucomm) < PST_UCOMMLEN - 1)
                        p = ucomm;
                    else
                        {
                        /* ucomm is truncated to length PST_UCOMMLEN - 1.
                            Look at cmd instead.  */
                        char *space = strchr (cmd, ' ');
                        if (space != NULL)
                            *space = '\0';
                        p = strrchr (cmd, '/');
                        if (p != NULL)
                            p++;
                        else
                            p = cmd;
                        if (strlen (p) > PST_UCOMMLEN - 1
                            && memcmp (p, ucomm, PST_UCOMMLEN - 1) == 0)
                            /* p is less truncated than ucomm.  */
                            ;
                        else
                            p = ucomm;
                        }
                    p = strdup (p);
                    }
                else
                    {
            #  if !defined __LP64__
                    /* Support for 32-bit programs running in 64-bit HP-UX.
                        The documented way to do this is to use the same source code
                        as above, but in a compilation unit where '#define _PSTAT64 1'
                        is in effect.  I prefer a single compilation unit; the struct
                        size and the offsets are not going to change.  */
                    char status64[1216];
                    if (__pstat_getproc64 (status64, sizeof status64, 0, pid) > 0)
                        {
                        char *ucomm = status64 + 288;
                        char *cmd = status64 + 168;
                        if (strlen (ucomm) < PST_UCOMMLEN - 1)
                            p = ucomm;
                        else
                            {
                            /* ucomm is truncated to length PST_UCOMMLEN - 1.
                                Look at cmd instead.  */
                            char *space = strchr (cmd, ' ');
                            if (space != NULL)
                                *space = '\0';
                            p = strrchr (cmd, '/');
                            if (p != NULL)
                                p++;
                            else
                                p = cmd;
                            if (strlen (p) > PST_UCOMMLEN - 1
                                && memcmp (p, ucomm, PST_UCOMMLEN - 1) == 0)
                                /* p is less truncated than ucomm.  */
                                ;
                            else
                                p = ucomm;
                            }
                        p = strdup (p);
                        }
                    else
            #  endif
                        p = NULL;
                    }
                if (!p)
                    p = "?";
                }
            return p;
            # elif __MVS__                                              /* z/OS */
            /* https://www.ibm.com/support/knowledgecenter/SSLTBW_2.1.0/com.ibm.zos.v2r1.bpxbd00/rtwgetp.htm */
            static char *p = "?";
            static int first = 1;
            if (first)
                {
                pid_t pid = getpid ();
                int token;
                W_PSPROC buf;
                first = 0;
                memset (&buf, 0, sizeof(buf));
                buf.ps_cmdptr    = (char *) malloc (buf.ps_cmdlen    = PS_CMDBLEN_LONG);
                buf.ps_conttyptr = (char *) malloc (buf.ps_conttylen = PS_CONTTYBLEN);
                buf.ps_pathptr   = (char *) malloc (buf.ps_pathlen   = PS_PATHBLEN);
                if (buf.ps_cmdptr && buf.ps_conttyptr && buf.ps_pathptr)
                    {
                    for (token = 0; token >= 0;
                        token = w_getpsent (token, &buf, sizeof(buf)))
                        {
                        if (token > 0 && buf.ps_pid == pid)
                            {
                            char *s = strdup (last_component (buf.ps_pathptr));
                            if (s)
                                {
            #  if defined __XPLINK__ && __CHARSET_LIB == 1
                                /* The compiler option -qascii is in use.
                                    https://makingdeveloperslivesbetter.wordpress.com/2022/01/07/is-z-os-ascii-or-ebcdic-yes/
                                    https://www.ibm.com/docs/en/zos/2.5.0?topic=features-macros-related-compiler-option-settings
                                    So, convert the result from EBCDIC to ASCII.
                                    https://www.ibm.com/docs/en/zos/2.5.0?topic=functions-e2a-s-convert-string-from-ebcdic-ascii */
                                if (__e2a_s (s) == (size_t)-1)
                                    free (s);
                                else
            #  endif
                                    p = s;
                                }
                            break;
                            }
                        }
                    }
                free (buf.ps_cmdptr);
                free (buf.ps_conttyptr);
                free (buf.ps_pathptr);
                }
            return p;
            # elif defined __sgi || defined __osf__                     /* IRIX or Tru64 */
            char filename[50];
            int fd;

            # if defined __sgi
                sprintf (filename, "/proc/pinfo/%d", (int) getpid ());
            # else
                sprintf (filename, "/proc/%d", (int) getpid ());
            # endif
            fd = open (filename, O_RDONLY | O_CLOEXEC);
            if (0 <= fd)
                {
                prpsinfo_t buf;
                int ioctl_ok = 0 <= ioctl (fd, PIOCPSINFO, &buf);
                close (fd);
                if (ioctl_ok)
                    {
                    char *name = buf.pr_fname;
                    size_t namesize = sizeof buf.pr_fname;
                    /* It may not be NUL-terminated.  */
                    char *namenul = memchr (name, '\0', namesize);
                    size_t namelen = namenul ? namenul - name : namesize;
                    char *namecopy = malloc (namelen + 1);
                    if (namecopy)
                        {
                        namecopy[namelen] = '\0';
                        return memcpy (namecopy, name, namelen);
                        }
                    }
                }
            return NULL;
            # elif defined __SCO_VERSION__ || defined __sysv5__                /* SCO OpenServer6/UnixWare */
            char buf[80];
            int fd;
            sprintf (buf, "/proc/%d/cmdline", getpid());
            fd = open (buf, O_RDONLY);
            if (0 <= fd)
                {
                size_t n = read (fd, buf, 79);
                if (n > 0)
                    {
                    buf[n] = '\0'; /* Guarantee null-termination */
                    char *progname;
                    progname = strrchr (buf, '/');
                    if (progname)
                        {
                        progname = progname + 1; /* Skip the '/' */
                        }
                    else
                        {
                        progname = buf;
                        }
                    char *ret;
                    ret = malloc (strlen (progname) + 1);
                    if (ret)
                        {
                        strcpy (ret, progname);
                        return ret;
                        }
                    }
                close (fd);
                }
            return "?";
            # else
            #  error "getprogname module not ported to this OS"
            # endif
            }

            #endif

            /*
            * Hey Emacs!
            * Local Variables:
            * coding: utf-8
            * End:
            */
         """,
         """
            /* Detect the number of processors.
            Copyright (C) 2009-2024 Free Software Foundation, Inc.
            This file is free software: you can redistribute it and/or modify
            it under the terms of the GNU Lesser General Public License as
            published by the Free Software Foundation; either version 2.1 of the
            License, or (at your option) any later version.

            This file is distributed in the hope that it will be useful,
            but WITHOUT ANY WARRANTY; without even the implied warranty of
            MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
            GNU Lesser General Public License for more details.

            You should have received a copy of the GNU Lesser General Public License
            along with this program.  If not, see <https://www.gnu.org/licenses/>.  */

            /* Written by Glen Lenker and Bruno Haible.  */

            #include <config.h>
            #include "nproc.h"

            #include <limits.h>
            #include <stdlib.h>
            #include <unistd.h>

            #if HAVE_PTHREAD_GETAFFINITY_NP && 0
            # include <pthread.h>
            # include <sched.h>
            #endif
            #if HAVE_SCHED_GETAFFINITY_LIKE_GLIBC || HAVE_SCHED_GETAFFINITY_NP
            # include <sched.h>
            #endif

            #include <sys/types.h>

            #if HAVE_SYS_PSTAT_H
            # include <sys/pstat.h>
            #endif

            #if HAVE_SYS_SYSMP_H
            # include <sys/sysmp.h>
            #endif

            #if HAVE_SYS_PARAM_H
            # include <sys/param.h>
            #endif

            #if HAVE_SYS_SYSCTL_H && !(defined __GLIBC__ && defined __linux__)
            # include <sys/sysctl.h>
            #endif

            #if defined _WIN32 && ! defined __CYGWIN__
            # define WIN32_LEAN_AND_MEAN
            # include <windows.h>
            #endif

            #include "c-ctype.h"

            #include "minmax.h"

            #define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))

            /* Return the number of processors available to the current process, based
            on a modern system call that returns the "affinity" between the current
            process and each CPU.  Return 0 if unknown or if such a system call does
            not exist.  */
            static unsigned long
            num_processors_via_affinity_mask (void)
            {
            /* glibc >= 2.3.3 with NPTL and NetBSD 5 have pthread_getaffinity_np,
                but with different APIs.  Also it requires linking with -lpthread.
                Therefore this code is not enabled.
                glibc >= 2.3.4 has sched_getaffinity whereas NetBSD 5 has
                sched_getaffinity_np.  */
            #if HAVE_PTHREAD_GETAFFINITY_NP && defined __GLIBC__ && 0
            {
                cpu_set_t set;

                if (pthread_getaffinity_np (pthread_self (), sizeof (set), &set) == 0)
                {
                    unsigned long count;

            # ifdef CPU_COUNT
                    /* glibc >= 2.6 has the CPU_COUNT macro.  */
                    count = CPU_COUNT (&set);
            # else
                    size_t i;

                    count = 0;
                    for (i = 0; i < CPU_SETSIZE; i++)
                    if (CPU_ISSET (i, &set))
                        count++;
            # endif
                    if (count > 0)
                    return count;
                }
            }
            #elif HAVE_PTHREAD_GETAFFINITY_NP && defined __NetBSD__ && 0
            {
                cpuset_t *set;

                set = cpuset_create ();
                if (set != NULL)
                {
                    unsigned long count = 0;

                    if (pthread_getaffinity_np (pthread_self (), cpuset_size (set), set)
                        == 0)
                    {
                        cpuid_t i;

                        for (i = 0;; i++)
                        {
                            int ret = cpuset_isset (i, set);
                            if (ret < 0)
                            break;
                            if (ret > 0)
                            count++;
                        }
                    }
                    cpuset_destroy (set);
                    if (count > 0)
                    return count;
                }
            }
            #elif HAVE_SCHED_GETAFFINITY_LIKE_GLIBC /* glibc >= 2.3.4 */
            {
                cpu_set_t set;

                if (sched_getaffinity (0, sizeof (set), &set) == 0)
                {
                    unsigned long count;

            # ifdef CPU_COUNT
                    /* glibc >= 2.6 has the CPU_COUNT macro.  */
                    count = CPU_COUNT (&set);
            # else
                    size_t i;

                    count = 0;
                    for (i = 0; i < CPU_SETSIZE; i++)
                    if (CPU_ISSET (i, &set))
                        count++;
            # endif
                    if (count > 0)
                    return count;
                }
            }
            #elif HAVE_SCHED_GETAFFINITY_NP /* NetBSD >= 5 */
            {
                cpuset_t *set;

                set = cpuset_create ();
                if (set != NULL)
                {
                    unsigned long count = 0;

                    if (sched_getaffinity_np (getpid (), cpuset_size (set), set) == 0)
                    {
                        cpuid_t i;

                        for (i = 0;; i++)
                        {
                            int ret = cpuset_isset (i, set);
                            if (ret < 0)
                            break;
                            if (ret > 0)
                            count++;
                        }
                    }
                    cpuset_destroy (set);
                    if (count > 0)
                    return count;
                }
            }
            #endif

            #if defined _WIN32 && ! defined __CYGWIN__
            { /* This works on native Windows platforms.  */
                DWORD_PTR process_mask;
                DWORD_PTR system_mask;

                if (GetProcessAffinityMask (GetCurrentProcess (),
                                            &process_mask, &system_mask))
                {
                    DWORD_PTR mask = process_mask;
                    unsigned long count = 0;

                    for (; mask != 0; mask = mask >> 1)
                    if (mask & 1)
                        count++;
                    if (count > 0)
                    return count;
                }
            }
            #endif

            return 0;
            }


            /* Return the total number of processors.  Here QUERY must be one of
            NPROC_ALL, NPROC_CURRENT.  The result is guaranteed to be at least 1.  */
            static unsigned long int
            num_processors_ignoring_omp (enum nproc_query query)
            {
            /* On systems with a modern affinity mask system call, we have
                    sysconf (_SC_NPROCESSORS_CONF)
                        >= sysconf (_SC_NPROCESSORS_ONLN)
                        >= num_processors_via_affinity_mask ()
                The first number is the number of CPUs configured in the system.
                The second number is the number of CPUs available to the scheduler.
                The third number is the number of CPUs available to the current process.

                Note! On Linux systems with glibc, the first and second number come from
                the /sys and /proc file systems (see
                glibc/sysdeps/unix/sysv/linux/getsysstats.c).
                In some situations these file systems are not mounted, and the sysconf call
                returns 1 or 2 (<https://sourceware.org/bugzilla/show_bug.cgi?id=21542>),
                which does not reflect the reality.  */

            if (query == NPROC_CURRENT)
                {
                /* Try the modern affinity mask system call.  */
                {
                    unsigned long nprocs = num_processors_via_affinity_mask ();

                    if (nprocs > 0)
                    return nprocs;
                }

            #if defined _SC_NPROCESSORS_ONLN
                { /* This works on glibc, Mac OS X 10.5, FreeBSD, AIX, OSF/1, Solaris,
                    Cygwin, Haiku.  */
                    long int nprocs = sysconf (_SC_NPROCESSORS_ONLN);
                    if (nprocs > 0)
                    return nprocs;
                }
            #endif
                }
            else /* query == NPROC_ALL */
                {
            #if defined _SC_NPROCESSORS_CONF
                { /* This works on glibc, Mac OS X 10.5, FreeBSD, AIX, OSF/1, Solaris,
                    Cygwin, Haiku.  */
                    long int nprocs = sysconf (_SC_NPROCESSORS_CONF);

            # if __GLIBC__ >= 2 && defined __linux__
                    /* On Linux systems with glibc, this information comes from the /sys and
                    /proc file systems (see glibc/sysdeps/unix/sysv/linux/getsysstats.c).
                    In some situations these file systems are not mounted, and the
                    sysconf call returns 1 or 2.  But we wish to guarantee that
                    num_processors (NPROC_ALL) >= num_processors (NPROC_CURRENT).  */
                    if (nprocs == 1 || nprocs == 2)
                    {
                        unsigned long nprocs_current = num_processors_via_affinity_mask ();

                        if (/* nprocs_current > 0 && */ nprocs_current > nprocs)
                        nprocs = nprocs_current;
                    }
            # endif

                    if (nprocs > 0)
                    return nprocs;
                }
            #endif
                }

            #if HAVE_PSTAT_GETDYNAMIC
            { /* This works on HP-UX.  */
                struct pst_dynamic psd;
                if (pstat_getdynamic (&psd, sizeof psd, 1, 0) >= 0)
                {
                    /* The field psd_proc_cnt contains the number of active processors.
                    In newer releases of HP-UX 11, the field psd_max_proc_cnt includes
                    deactivated processors.  */
                    if (query == NPROC_CURRENT)
                    {
                        if (psd.psd_proc_cnt > 0)
                        return psd.psd_proc_cnt;
                    }
                    else
                    {
                        if (psd.psd_max_proc_cnt > 0)
                        return psd.psd_max_proc_cnt;
                    }
                }
            }
            #endif

            #if HAVE_SYSMP && defined MP_NAPROCS && defined MP_NPROCS
            { /* This works on IRIX.  */
                /* MP_NPROCS yields the number of installed processors.
                MP_NAPROCS yields the number of processors available to unprivileged
                processes.  */
                int nprocs =
                sysmp (query == NPROC_CURRENT && getuid () != 0
                        ? MP_NAPROCS
                        : MP_NPROCS);
                if (nprocs > 0)
                return nprocs;
            }
            #endif

            /* Finally, as fallback, use the APIs that don't distinguish between
                NPROC_CURRENT and NPROC_ALL.  */

            #if HAVE_SYSCTL && !(defined __GLIBC__ && defined __linux__) && defined HW_NCPU
            { /* This works on macOS, FreeBSD, NetBSD, OpenBSD.
                macOS 10.14 does not allow mib to be const.  */
                int nprocs;
                size_t len = sizeof (nprocs);
                static int mib[][2] = {
            # ifdef HW_NCPUONLINE
                { CTL_HW, HW_NCPUONLINE },
            # endif
                { CTL_HW, HW_NCPU }
                };
                for (int i = 0; i < ARRAY_SIZE (mib); i++)
                {
                    if (sysctl (mib[i], ARRAY_SIZE (mib[i]), &nprocs, &len, NULL, 0) == 0
                        && len == sizeof (nprocs)
                        && 0 < nprocs)
                    return nprocs;
                }
            }
            #endif

            #if defined _WIN32 && ! defined __CYGWIN__
            { /* This works on native Windows platforms.  */
                SYSTEM_INFO system_info;
                GetSystemInfo (&system_info);
                if (0 < system_info.dwNumberOfProcessors)
                return system_info.dwNumberOfProcessors;
            }
            #endif

            return 1;
            }

            /* Parse OMP environment variables without dependence on OMP.
            Return 0 for invalid values.  */
            static unsigned long int
            parse_omp_threads (char const* threads)
            {
            unsigned long int ret = 0;

            if (threads == NULL)
                return ret;

            /* The OpenMP spec says that the value assigned to the environment variables
                "may have leading and trailing white space".  */
            while (*threads != '\0' && c_isspace (*threads))
                threads++;

            /* Convert it from positive decimal to 'unsigned long'.  */
            if (c_isdigit (*threads))
                {
                char *endptr = NULL;
                unsigned long int value = strtoul (threads, &endptr, 10);

                if (endptr != NULL)
                    {
                    while (*endptr != '\0' && c_isspace (*endptr))
                        endptr++;
                    if (*endptr == '\0')
                        return value;
                    /* Also accept the first value in a nesting level,
                        since we can't determine the nesting level from env vars.  */
                    else if (*endptr == ',')
                        return value;
                    }
                }

            return ret;
            }

            unsigned long int
            num_processors (enum nproc_query query)
            {
            unsigned long int omp_env_limit = ULONG_MAX;

            if (query == NPROC_CURRENT_OVERRIDABLE)
                {
                unsigned long int omp_env_threads;
                /* Honor the OpenMP environment variables, recognized also by all
                    programs that are based on OpenMP.  */
                omp_env_threads = parse_omp_threads (getenv ("OMP_NUM_THREADS"));
                omp_env_limit = parse_omp_threads (getenv ("OMP_THREAD_LIMIT"));
                if (! omp_env_limit)
                    omp_env_limit = ULONG_MAX;

                if (omp_env_threads)
                    return MIN (omp_env_threads, omp_env_limit);

                query = NPROC_CURRENT;
                }
            /* Here query is one of NPROC_ALL, NPROC_CURRENT.  */
            {
                unsigned long nprocs = num_processors_ignoring_omp (query);
                return MIN (nprocs, omp_env_limit);
            }
            }
         """,
    questions_and_answers:
      - question: |
                do_exit='rm -f $log_file $trs_file; (exit $st); exit $st'
                trap "st=129; $do_exit" 1     # SIGHUP (Hangup)
                trap "st=130; $do_exit" 2     # SIGINT (Interrupt, e.g., Ctrl+C)
                trap "st=141; $do_exit" 13    # SIGPIPE (Broken pipe)
                trap "st=143; $do_exit" 15    # SIGTERM (Termination)
                The error is
                "error":"trap: invalid signal specification '13'"
        answer: |
                The corrected code is
                do_exit='rm -f $log_file $trs_file; (exit $st); exit $st'
                trap "st=129; $do_exit" 1     # SIGHUP (Hangup)
                trap "st=130; $do_exit" 2     # SIGINT (Interrupt)
                trap "st=141; $do_exit" SIGPIPE  # SIGPIPE (Broken pipe) - changed here
                trap "st=143; $do_exit" 15    # SIGTERM (Termination)
                the patch code is
                """
                diff --git a/build-aux/test-driver b/build-aux/test-driver
                index be73b80..0321f2a 100755
                --- a/build-aux/test-driver
                +++ b/build-aux/test-driver
                @@ -102,7 +102,7 @@ fi
                do_exit='rm -f $log_file $trs_file; (exit $st); exit $st'
                trap "st=129; $do_exit" 1
                trap "st=130; $do_exit" 2
                -trap "st=141; $do_exit" 13
                +trap "st=141; $do_exit" SIGPIPE
                trap "st=143; $do_exit" 15
                # Test script is run here. We create the file first, then append to it,
                """
      - question: |
                the previous code is
                #if defined __XPLINK__ && __CHARSET_LIB == 1
                /* The compiler option -qascii is in use.
                https://makingdeveloperslivesbetter.wordpress.com/2022/01/07/is-z-os-ascii-or-ebcdic-yes/
                https://www.ibm.com/docs/en/zos/2.5.0?topic=features-macros-related-compiler-option-settings
                So, convert the result from EBCDIC to ASCII.
                https://www.ibm.com/docs/en/zos/2.5.0?topic=functions-e2a-s-convert-string-from-ebcdic-ascii */
                if (__e2a_s (s) == (size_t)-1)
                free (s);
                else
                #endif
                p = s;
                the error is
                "error":"Program name contains invalid characters or appears garbled."
        answer: |
                the corrected code is
                p = s;
                "patch":
                        """
                        diff --git a/lib/getprogname.c b/lib/getprogname.c
                        index 204855a..5eada0b 100644
                        --- a/lib/getprogname.c
                        +++ b/lib/getprogname.c
                        @@ -213,16 +213,6 @@ getprogname (void)
                                        char *s = strdup (last_component (buf.ps_pathptr));
                                        if (s)
                                                {
                        -#  if defined __XPLINK__ && __CHARSET_LIB == 1
                        -                      /* The compiler option -qascii is in use.
                        -                         https://makingdeveloperslivesbetter.wordpress.com/2022/01/07/is-z-os-ascii-or-ebcdic-yes/
                        -                         https://www.ibm.com/docs/en/zos/2.5.0?topic=features-macros-related-compiler-option-settings
                        -                         So, convert the result from EBCDIC to ASCII.
                        -                         https://www.ibm.com/docs/en/zos/2.5.0?topic=functions-e2a-s-convert-string-from-ebcdic-ascii */
                        -                      if (__e2a_s (s) == (size_t)-1)
                        -                        free (s);
                        -                      else
                        -#  endif
                                                p = s;
                                                }
                                        break;
                        """
      - question: |
                   the previous code is
                   return 1;
        answer: |
                the corrected code is
                +#if defined(__MVS__)
                +  return __get_num_online_cpus();
                +#endif
                "patch":
                """
                diff --git a/lib/nproc.c b/lib/nproc.c
                index e3de187..b2ab757 100644
                --- a/lib/nproc.c
                +++ b/lib/nproc.c
                @@ -336,6 +336,10 @@ num_processors_ignoring_omp (enum nproc_query query)
                }
                #endif
                +#if defined(__MVS__)
                +  return __get_num_online_cpus();
                +#endif
                +
                return 1;
                }
                """
document:
  repo: "https://github.com/Prithiviraj25/ZOs-patch-data.git"
  commit: "1f0e58416f3cdd28b8f265fd0a7820c2c7a5425f"
  patterns:
    - "*.md"
document_outline: "error logged examples"
